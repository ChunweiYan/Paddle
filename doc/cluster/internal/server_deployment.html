<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>服务端部署 &mdash; PaddlePaddle  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PaddlePaddle  documentation" href="../../index.html" />
    <link rel="up" title="PaddlePaddle新平台" href="index.html" />
    <link rel="next" title="高级使用(Advanced Usage)" href="advanced_usage.html" />
    <link rel="prev" title="集群任务配置说明" href="cluster_config.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="advanced_usage.html" title="高级使用(Advanced Usage)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cluster_config.html" title="集群任务配置说明"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PaddlePaddle  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Cluster Train</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">PaddlePaddle新平台</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="">
<span id="id1"></span><h1>服务端部署<a class="headerlink" href="#" title="Permalink to this headline">¶</a></h1>
<p>如果您确定自己所使用的集群已部署好PaddlePaddle新平台，可以跳过此章节。如果您想让自己使用的集群能够通过新平台提交任务，通常不需要自己搭建服务端，您只需要将集群的具体信息(包括服务器的地址、集群类型、软件环境等)提供给我们，我们在现有的Receiver中添加上该集群对应的配置文件，就可以正常使用了。</p>
<p>PaddlePaddle新平台的服务端部署主要指用户搭建一个或多个<code class="docutils literal"><span class="pre">Receiver</span></code>（您可以将Receiver看做是一个任务代理服务器，您提交的任务配置和其他文件首先被Receiver接收，随后Receiver根据配置再将任务提交的指定的集群），多个Receiver可以搭建在同一台机器上，同时部署一个<code class="docutils literal"><span class="pre">log_server</span></code>来收集Receiver日志，一个<code class="docutils literal"><span class="pre">monitor</span></code>来监控Receiver的运行状态。</p>
<p>新平台的服务端架构如下图所示：</p>
<p><img alt="platform_arch" src="cluster/internal/paddle_platform_arch.png" /></p>
<div class="section" id="receiver">
<span id="receiver"></span><h2>Receiver部署<a class="headerlink" href="#receiver" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>下载源码</li>
<li>编译打包平台化bin包：部分提交集群需要特殊的运行时环境，比如box集群，所以建议特殊集群自己编译打包。<ul>
<li>按照paddle编译流程，下载完整的源码包</li>
<li>进入platform2目录，<code class="docutils literal"><span class="pre">sh</span> <span class="pre">build.sh</span></code>，在当前目录会生产一个build输出。 默认包含了cpu/gpu/rdma多种混合集群的二进制程序</li>
</ul>
</li>
<li>更新系统环境变量</li>
</ul>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">cd</span> platform2/scheduler/receiver/tools
sh install_hpc_client.sh
</pre></div>
</div>
<ul class="simple">
<li>设置自动部署脚本</li>
</ul>
<p>因为平台化脚本提交过程包含很多本地磁盘文件的修改过程，同时每个receiver需要独立维护一个平台化脚本，所以默认不支持同时提交多个任务。现在部署方法简单粗暴，支持克隆一份完整的平台化和scheduler脚本，实现一个完整的receiver instance。
<code class="docutils literal"><span class="pre">platform2/scheduler/receiver/tools</span></code>提供了一个自动部署脚本，会根据配置自动构造若干receiver的所需环境，需要设置一下参数：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">receivers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;127.0.0.1:9090&quot;</span><span class="p">,</span>
    <span class="s2">&quot;127.0.0.1:9091&quot;</span><span class="p">,</span>
    <span class="s2">&quot;127.0.0.1:9092&quot;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="n">platform</span> <span class="o">=</span> <span class="s2">&quot;/home/wangyanfei/paddle.ci.platform/idl/paddle/platform2.next/build/paddle_cmd_gcc48_avx_float_api_1052/train&quot;</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="s2">&quot;/home/wangyanfei/paddle.ci.platform/idl/paddle/platform2.next/scheduler&quot;</span>
<span class="n">deploy_dir</span> <span class="o">=</span> <span class="s2">&quot;/home/wangyanfei/tmp/platform2_deployment&quot;</span>
<span class="n">log_server</span> <span class="o">=</span> <span class="s2">&quot;yq01-idl-gpu-offline14.yq01.baidu.com:9900&quot;</span>
</pre></div>
</div>
<ol class="simple">
<li>receivers： 启动server端口和监听地址</li>
<li>platform：  本机的platfrom客户端目录</li>
<li>scheduler：调度模块的目录</li>
<li>deploy_dir:  部署目录</li>
<li>log_server:  日志服务地址，receiver会将相关job请求发送到log服务</li>
</ol>
<p>脚本会在<code class="docutils literal"><span class="pre">deploy_dir</span></code>克隆若干副本，并启动相关scheduler服务。</p>
<ul class="simple">
<li>修改支持的集群列表</li>
</ul>
<p>部分receiver可能不支持某些特殊集群，比如box集群因为环境特殊，需要在box集群编译的PaddlePaddle二进制，所以此时可以disable对应的集群配置，达到禁止通过该receiver提交特定集群的功能。
比如，对于非box节点上的receiver禁止调度执行box集群的作业，那么直接删除平台化目录内的<code class="docutils literal"><span class="pre">paddle_cmd_gcc48_avx_float_api_1083/train/core/nodes.configs/yq01-ecom-triger-box_slurm_cluster</span></code>文件夹即可。</p>
<ul class="simple">
<li>其他</li>
</ul>
<p>部署脚本生成的receiver instances目录，文件名以receiver地址和端口号命名。建议receiver使用hostname形式的receiver地址而不是ip地址形式，提高可读性，容易确定receiver部署在什么机房。</p>
</div>
<div class="section" id="log-server">
<span id="log-server"></span><h2>Log Server部署<a class="headerlink" href="#log-server" title="Permalink to this headline">¶</a></h2>
<p>Log Server用于收集一个或多个Receiver产生的日志，当前记录的内容包括<code class="docutils literal"><span class="pre">Job</span> <span class="pre">Config,</span> <span class="pre">Tracking</span> <span class="pre">Url</span></code>等信息，这些信息在未来可以用于详细的实验历史分析，帮助用户分析参数调整的过程和效果的变化。在前面的Receiver部署中，用户已经指定了Log Server的地址，这个地址可以与Receiver在相同的机器上也可以使用单独的机器。如果要开启Log Server服务，请将Log Server启动脚本拷贝到您部署Receiver时指定的log_server机器上，启动脚本位于您部署Receiver时指定的<code class="docutils literal"><span class="pre">deploy_dir/receiver_name/scheduler/receiver/log_server</span></code>下面。</p>
<p>启动Log Server的命令如下:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>usage: log_server.py <span class="o">[</span>-h<span class="o">]</span> <span class="o">[</span>-p PORT<span class="o">]</span> <span class="o">[</span>-f LOG_FILE<span class="o">]</span>

log paddlepaddle <span class="nb">jobs</span> and signal hetu.baidu.com

optional arguments:
    -h, --help            show this <span class="nb">help</span> message and <span class="nb">exit</span>
    -p PORT, --port PORT  port of logging server
    -f LOG_FILE, --log_file LOG_FILE
                          running log <span class="k">for</span> log server
</pre></div>
</div>
<p>此处须注意指定的端口，要与部署Receiver时指定的log_server端口一致。</p>
</div>
<div class="section" id="monitor">
<span id="monitor"></span><h2>Monitor部署<a class="headerlink" href="#monitor" title="Permalink to this headline">¶</a></h2>
<p>Monitor会监控receivers服务状态，间隔（默认60sec）一段时间确认receiver是否alive，并对异常、异常恢复等发送邮件通知，确保服务正常运作。</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">all receivers needed to be check alive</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">receivers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;yq01-ecom-triger-box01.yq01.baidu.com:9090&quot;</span><span class="p">,</span>
        <span class="o">...</span>
        <span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">mail list to receive warning message</span>

<span class="sd">if any receive failed, send warning mails</span>
<span class="sd">send abstract mail each week even if no failure is found.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">warning_maillist</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;wangyanfei01@baidu.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;luotao02@baidu.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;yuyang18@baidu.com&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dangqingqing@baidu.com&quot;</span><span class="p">,</span>
        <span class="p">]</span>
</pre></div>
</div>
<p>Monitor位于log_server的同级目录。您只需要配置被监控的receivers的列表，以及报警的通知邮件列表，然后启动monitor服务：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>python monitor.py
</pre></div>
</div>
</div>
<div class="section" id="mpi">
<span id="mpi"></span><h2>接入新MPI集群<a class="headerlink" href="#mpi" title="Permalink to this headline">¶</a></h2>
<div class="section" id="physical-cluster">
<span id="physical-cluster"></span><h3>接入物理集群(Physical Cluster)<a class="headerlink" href="#physical-cluster" title="Permalink to this headline">¶</a></h3>
<p>新平台化架构在理论上对于任意一个receiver允许接入任意的MPI集群，包括接入GPU集群和CPU集群。
实际上，不同物理集群表现的特殊性覆盖层面较多，比如高速互联网路底层配置和RDMA相关运行时环境相应接口，GPU运行时环境、物理GPU卡数目和cudnn运行时库版本支持，物理集群对应调度器版本和调度器运行时依赖等等。
甚至例如BOX集群完全非标准化服务器等，会导致极少量集群在支持新MPI集群的时候需要重新部署单独的receiver。</p>
<p>一般情况下，为了支持接入一个新的物理MPI集群，仅仅需要在相应的receiver端的<code class="docutils literal"><span class="pre">train/core/nodes.configs/</span></code>下准备一个新的集群配置即可。</p>
<p>TODO: 示例接入一个新的CPU集群和新的物理集群</p>
</div>
<div class="section" id="visual-cluster">
<span id="visual-cluster"></span><h3>接入虚拟集群(Visual Cluster)<a class="headerlink" href="#visual-cluster" title="Permalink to this headline">¶</a></h3>
<p>新平台为了优化用户体验，让常规用户无需关注集群相关细节。但是用户如果想高效利用集群，可能需要设置集群部分参数，如采用GPU计算和CPU端存储混部的集群架构，来满足对大数据存储和访问的高效性。
为此，新平台通过虚拟集群的设计来满足此类需求。</p>
<p>虚拟集群定义为<code class="docutils literal"><span class="pre">物理集群+特定集群配置</span></code>的一个集群，普通用户完全不用考虑两者的区别，仅需要关心特定集群的使用方法。
比如，yq01-idl-idl-offline_slurm_cluster、yq01-idl-idl-offline_vfs_slurm_cluster和yq01-idl-idl-offline_vfs_metric_learning_slurm_cluster，这个三个虚拟集群同属一个物理集群。
其中vfs关键字的集群混部了HDFS存储和GPU计算，对于图像训练上TB的数据，可以避免训练前等待数据下载，优化训练周期时间和数据访存时间。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">服务端部署</a><ul>
<li><a class="reference internal" href="#receiver">Receiver部署</a></li>
<li><a class="reference internal" href="#log-server">Log Server部署</a></li>
<li><a class="reference internal" href="#monitor">Monitor部署</a></li>
<li><a class="reference internal" href="#mpi">接入新MPI集群</a><ul>
<li><a class="reference internal" href="#physical-cluster">接入物理集群(Physical Cluster)</a></li>
<li><a class="reference internal" href="#visual-cluster">接入虚拟集群(Visual Cluster)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cluster_config.html"
                        title="previous chapter">集群任务配置说明</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="advanced_usage.html"
                        title="next chapter">高级使用(Advanced Usage)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/cluster/internal/server_deployment.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="advanced_usage.html" title="高级使用(Advanced Usage)"
             >next</a> |</li>
        <li class="right" >
          <a href="cluster_config.html" title="集群任务配置说明"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PaddlePaddle  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Cluster Train</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >PaddlePaddle新平台</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, PaddlePaddle developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>