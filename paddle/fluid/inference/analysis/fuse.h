/* Copyright (c) 2018 PaddlePaddle Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License. */

#include "paddle/fluid/inference/analysis/data_flow_graph.h"
#include "paddle/fluid/inference/analysis/node.h"

namespace paddle {
namespace inference {
namespace analysis {
namespace fuse {

struct PatternRecord;

using hit_t = std::pair<Node*, int32_t>;

class Pattern {
 public:
  using handle_t =
      std::function<void(const PatternRecord& pattern, DataFlowGraph* graph)>;

  FusePatternNode* AddNode();
  void AddEdge(FusePatternNode* source, FusePatternNode* target);
  void SetHandle(const handle_t& handle);

  // Extract all the sub-graphs that match a pattern, mark the nodes with a
  // pattern-id(unique for different matched results).
  std::vector<PatternRecord> Match(DataFlowGraph* graph);

  // Fuse the nodes inside a pattern with a Node generated by a `handle`.
  void Fuse(DataFlowGraph* graph);

 private:
  void MarkNodesInPattern(DataFlowGraph* graph);

  std::vector<std::pair<hit_t, hit_t>> Extract2GramPatterns(
      DataFlowGraph* graph);

  std::vector<PatternRecord> ExtractPatterns(
      DataFlowGraph* graph, const std::vector<PatternRecord>& init_patterns);

 private:
  handle_t handle_;
  DataFlowGraph pattern_graph_;
  std::unordered_map<int32_t /*pnode_id*/, std::unordered_set<Node*> /*nodes*/>
      pattern_to_node_map_;
};

struct PatternRecord {
  std::unordered_map<int32_t /*pattern id*/, Node*> symbol_table;
  std::vector<hit_t> hits;

  PatternRecord() = default;

  PatternRecord(const PatternRecord& o) = default;

  PatternRecord(const hit_t& source, const hit_t target) {
    if (!MatchOrInsert(source.first, source.second)) return;
    if (!MatchOrInsert(target.first, target.second)) return;
  }

  bool is_valid() const { return valid_; }
  void set_valid() { valid_ = true; }
  void set_invalid() { valid_ = false; }

  bool MatchOrInsert(Node* node, int32_t pnode_id) {
    if (!symbol_table.count(pnode_id)) {
      symbol_table[pnode_id] = node;
    }
    return symbol_table[pnode_id] == node;
  }

  bool Match(const Node* node, int32_t pnode_id) const {
    return (!symbol_table.count(pnode_id)) || symbol_table.at(pnode_id) == node;
  }

 private:
  bool valid_{true};
};

}  // namespace fuse
}  // namespace analysis
}  // namespace inference
}  // namespace paddle
