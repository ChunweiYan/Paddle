<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Writing New Layers &mdash; PaddlePaddle  documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PaddlePaddle  documentation" href="../../index.html" />
    <link rel="up" title="Examples and demos" href="../index.html" />
    <link rel="next" title="Cluster Train" href="../../cluster/index.html" />
    <link rel="prev" title="Chinese Word Embedding Model Tutorial" href="../embedding_model/index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../cluster/index.html" title="Cluster Train"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../embedding_model/index.html" title="Chinese Word Embedding Model Tutorial"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PaddlePaddle  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Examples and demos</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="writing-new-layers">
<span id="writing-new-layers"></span><h1>Writing New Layers<a class="headerlink" href="#writing-new-layers" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will guide you to write customized layers in PaddlePaddle. We will utilize fully connected layer as an example to guide you through the following steps for writing a new layer.</p>
<ul class="simple">
<li>Derive equations for the forward and backward part of the layer.</li>
<li>Implement C++ class for the layer.</li>
<li>Implement Python Wrapper for the layer.</li>
</ul>
</div>
<div class="section" id="derive-equations">
<span id="derive-equations"></span><h1>Derive Equations<a class="headerlink" href="#derive-equations" title="Permalink to this headline">¶</a></h1>
<p>First we need to derive equations of the <em>forward</em> and <em>backward</em> part of the layer. The forward part computes the output given an input. The backward part computes the gradients of the input and the parameters given the the gradients of the output.</p>
<p>The illustration of a fully connected layer is shown in the following figure. In a fully connected layer, all output nodes are connected to all the input nodes.
<center> <img alt="" src="../../_images/FullyConnected.jpg" /> </center></p>
<p>The <em>forward part</em> of a layer transforms an input into the corresponding output.
Fully connected layer takes a dense input vector with dimension $D_i$. It uses a transformation matrix $W$ with size $D_i \times D_o$ to project x into a $D_o$ dimensional vector, and add a bias vector  $b$ with dimension $D_o$ to the vector.
[y = f(W^T x + b) ]
where $f(.)$ is an nonlinear <em>activation</em> function, such as sigmoid, tanh, and Relu.</p>
<p>The transformation matrix $W$ and bias vector $b$ are the <em>parameters</em> of the layer. The <em>parameters</em> of a layer are learned during training in the <em>backward pass</em>. The backward pass computes the gradients of the output function with respect to all parameters and inputs. The optimizer can use chain rule to compute the gradients of the loss function with respect to each parameter. Suppose our loss function is $c(y)$, then
[\frac{\partial c(y)}{\partial x} = \frac{\partial c(y)}{\partial y} \frac{\partial y}{\partial x} ]</p>
<p>Suppose $z = f(W^T x + b)$, then
[ \frac{\partial y}{\partial z} = \frac{\partial f(z)}{\partial z}]
This derivative can be automatically computed by our base layer class.</p>
<p>Then, for fully connected layer, we need to compute $\frac{\partial z}{\partial x}$, and $\frac{\partial z}{\partial W}$, and $\frac{\partial z}{\partial b}$.
[ \frac{\partial z}{\partial x} = W ]
[ \frac{\partial z_j}{\partial W_{ij}} = x_i ]
[ \frac{\partial z}{\partial b} = \mathbf 1 ]
where $\mathbf 1$ is an all one vector, $W_{ij}$ is the number at the i-th row and j-th column of the matrix $W$, $z_j$ is the j-th component of the vector $z$, and $x_i$ is the i-th component of the vector $x$.</p>
<p>Then we can use chain rule to calculate $\frac{\partial z}{\partial x}$, and $\frac{\partial z}{\partial W}$. The details of the computation will be given in the next section.</p>
</div>
<div class="section" id="implement-c-class">
<span id="implement-c-class"></span><h1>Implement C++ Class<a class="headerlink" href="#implement-c-class" title="Permalink to this headline">¶</a></h1>
<p>The C++ class of the layer implements the initialization, forward, and backward part of the layer. The fully connected layer is at <code class="docutils literal"><span class="pre">paddle/gserver/layers/FullyConnectedLayer.h</span></code> and <code class="docutils literal"><span class="pre">paddle/gserver/layers/FullyConnectedLayer.cpp</span></code>. We list simplified version of the code below.</p>
<p>It needs to derive the base class <code class="docutils literal"><span class="pre">paddle::BaseLayer</span></code>, and it needs to override the following functions:</p>
<ul class="simple">
<li>constructor and destructor.</li>
<li><code class="docutils literal"><span class="pre">init</span></code> function. It is used to initialize the parameters and settings.</li>
<li><code class="docutils literal"><span class="pre">forward</span></code>. It implements the forward part of the layer.</li>
<li><code class="docutils literal"><span class="pre">backward</span></code>. It implements the backward part of the layer.</li>
<li><code class="docutils literal"><span class="pre">prefetch</span></code>. It is utilized to determine the rows corresponding parameter matrix to prefetch from parameter server. You do not need to override this function if your layer does not need remote sparse update. (most layers do not need to support remote sparse update)</li>
</ul>
<p>The header file is listed below:</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">paddle</span> <span class="p">{</span>
<span class="cm">/**</span>
<span class="cm"> * A layer has full connections to all neurons in the previous layer.</span>
<span class="cm"> * It computes an inner product with a set of learned weights, and</span>
<span class="cm"> * (optionally) adds biases.</span>
<span class="cm"> *</span>
<span class="cm"> * The config file api is fc_layer.</span>
<span class="cm"> */</span>

<span class="n">class</span> <span class="nl">FullyConnectedLayer</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Layer</span> <span class="p">{</span>
<span class="nl">protected</span><span class="p">:</span>
  <span class="n">WeightList</span> <span class="n">weights_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Weight</span><span class="o">&gt;</span> <span class="n">biases_</span><span class="p">;</span>

<span class="nl">public</span><span class="p">:</span>
  <span class="n">explicit</span> <span class="n">FullyConnectedLayer</span><span class="p">(</span><span class="k">const</span> <span class="n">LayerConfig</span><span class="o">&amp;</span> <span class="n">config</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Layer</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">FullyConnectedLayer</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="n">LayerMap</span><span class="o">&amp;</span> <span class="n">layerMap</span><span class="p">,</span> <span class="k">const</span> <span class="n">ParameterMap</span><span class="o">&amp;</span> <span class="n">parameterMap</span><span class="p">);</span>

  <span class="n">Weight</span><span class="o">&amp;</span> <span class="n">getWeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">weights_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">prefetch</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">forward</span><span class="p">(</span><span class="n">PassType</span> <span class="n">passType</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">backward</span><span class="p">(</span><span class="k">const</span> <span class="n">UpdateCallback</span><span class="o">&amp;</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace paddle</span>
</pre></div>
</div>
<p>It defines the parameters as class variables. We use <code class="docutils literal"><span class="pre">Weight</span></code> class as abstraction of parameters. It supports multi-thread update. The details of this class will be described in details in the implementations.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">weights_</span></code> is a list of weights for the transformation matrices. The current implementation can have more than one inputs. Thus, it has a list of weights. One weight corresponds to an input.</li>
<li><code class="docutils literal"><span class="pre">biases_</span></code> is a weight for the bias vector.</li>
</ul>
<p>The fully connected layer does not have layer configuration hyper-parameters. If there are some layer hyper-parameters, a common practice is to store it in <code class="docutils literal"><span class="pre">LayerConfig&amp;</span> <span class="pre">config</span></code>, and put it into a class variable in the constructor.</p>
<p>The following code snippet implements the <code class="docutils literal"><span class="pre">init</span></code> function.</p>
<ul class="simple">
<li>First, every <code class="docutils literal"><span class="pre">init</span></code> function must call the <code class="docutils literal"><span class="pre">init</span></code> function of the base class <code class="docutils literal"><span class="pre">Layer::init(layerMap,</span> <span class="pre">parameterMap);</span></code>. This statement will initialize the required variables and connections for each layer.</li>
<li>The it initializes all the weights matrices $W$. The current implementation can have more than one inputs. Thus, it has a list of weights.</li>
<li>Finally, it initializes the bias.</li>
</ul>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">FullyConnectedLayer</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="n">LayerMap</span><span class="o">&amp;</span> <span class="n">layerMap</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">ParameterMap</span><span class="o">&amp;</span> <span class="n">parameterMap</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Initialize the basic parent class */</span>
  <span class="n">Layer</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">layerMap</span><span class="p">,</span> <span class="n">parameterMap</span><span class="p">);</span>

  <span class="cm">/* initialize the weightList */</span>
  <span class="n">CHECK</span><span class="p">(</span><span class="n">inputLayers_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">parameters_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inputLayers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Option the parameters</span>
    <span class="kt">size_t</span> <span class="n">height</span> <span class="o">=</span> <span class="n">inputLayers_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">width</span> <span class="o">=</span> <span class="n">getSize</span><span class="p">();</span>

    <span class="c1">// create a new weight</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parameters_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">isSparse</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">CHECK_LE</span><span class="p">(</span><span class="n">parameters_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">parameters_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Weight</span><span class="o">*</span> <span class="n">w</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Weight</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">parameters_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="c1">// append the new weight to the list</span>
    <span class="n">weights_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* initialize biases_ */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">biasParameter_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">biases_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Weight</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">Weight</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">getSize</span><span class="p">(),</span> <span class="n">biasParameter_</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation of the forward part has the following steps.</p>
<ul class="simple">
<li>Every layer must call <code class="docutils literal"><span class="pre">Layer::forward(passType);</span></code> at the beginning of its <code class="docutils literal"><span class="pre">forward</span></code> function.</li>
<li>Then it allocates memory for the output using <code class="docutils literal"><span class="pre">reserveOutput(batchSize,</span> <span class="pre">size);</span></code>. This step is necessary because we support the batches to have different batch sizes. <code class="docutils literal"><span class="pre">reserveOutput</span></code> will change the size of the output accordingly. For the sake of efficiency, we will allocate new memory if we want to expand the matrix, but we will reuse the existing memory block if we want to shrink the matrix.</li>
<li>Then it computes $\sum_i W_i x + b$ using Matrix operations. <code class="docutils literal"><span class="pre">getInput(i).value</span></code> retrieve the matrix of the i-th input. Each input is a $batchSize \times dim$ matrix, where each row represents an single input in a batch. For a complete lists of supported matrix operations, please refer to <code class="docutils literal"><span class="pre">paddle/math/Matrix.h</span></code> and <code class="docutils literal"><span class="pre">paddle/math/BaseMatrix.h</span></code>.</li>
<li>Finally it applies the activation function using <code class="docutils literal"><span class="pre">forwardActivation();</span></code>. It will automatically applies the corresponding activation function specifies in the network configuration.</li>
</ul>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">FullyConnectedLayer</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">PassType</span> <span class="n">passType</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Layer</span><span class="o">::</span><span class="n">forward</span><span class="p">(</span><span class="n">passType</span><span class="p">);</span>

  <span class="cm">/* malloc memory for the output_ if necessary */</span>
  <span class="kt">int</span> <span class="n">batchSize</span> <span class="o">=</span> <span class="n">getInput</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getBatchSize</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">getSize</span><span class="p">();</span>

  <span class="p">{</span>
    <span class="c1">// Settup the size of the output.</span>
    <span class="n">reserveOutput</span><span class="p">(</span><span class="n">batchSize</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MatrixPtr</span> <span class="n">outV</span> <span class="o">=</span> <span class="n">getOutputValue</span><span class="p">();</span>

  <span class="c1">// Apply the the transformation matrix to each input.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">inputLayers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">input</span> <span class="o">=</span> <span class="n">getInput</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The input of &#39;fc&#39; layer must be matrix&quot;</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">outV</span><span class="o">-&gt;</span><span class="n">mul</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getW</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
           <span class="o">:</span> <span class="n">outV</span><span class="o">-&gt;</span><span class="n">mul</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getW</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* add the bias-vector */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">biases_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">outV</span><span class="o">-&gt;</span><span class="n">addBias</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">biases_</span><span class="o">-&gt;</span><span class="n">getW</span><span class="p">()),</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* activation */</span> <span class="p">{</span>
    <span class="n">forwardActivation</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation of the backward part has the following steps.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">backwardActivation();</span></code> computes the gradients of the activation. The gradients will be multiplies in place to the gradients of the output, which can be retrieved using <code class="docutils literal"><span class="pre">getOutputGrad()</span></code>.</li>
<li>Compute the gradients of bias. Notice that we an use <code class="docutils literal"><span class="pre">biases_-&gt;getWGrad()</span></code> to get the gradient matrix of the corresponding parameter. After the gradient of one parameter is updated, it <em>MUST</em> call <code class="docutils literal"><span class="pre">getParameterPtr()-&gt;incUpdate(callback);</span></code>. This is utilize for parameter update over multiple threads or multiple machines.</li>
<li>Then it computes the gradients of the transformation matrices and inputs, and it calls <code class="docutils literal"><span class="pre">incUpdate</span></code> for the corresponding parameter. This gives the framework the chance to know whether it has gathered all the gradient to one parameter so that it can do some overlapping work (e.g., network communication)</li>
</ul>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">FullyConnectedLayer</span><span class="o">::</span><span class="n">backward</span><span class="p">(</span><span class="k">const</span> <span class="n">UpdateCallback</span><span class="o">&amp;</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Do derivation for activations.*/</span> <span class="p">{</span>
    <span class="n">backwardActivation</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">biases_</span> <span class="o">&amp;&amp;</span> <span class="n">biases_</span><span class="o">-&gt;</span><span class="n">getWGrad</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">biases_</span><span class="o">-&gt;</span><span class="n">getWGrad</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">collectBias</span><span class="p">(</span><span class="o">*</span><span class="n">getOutputGrad</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* Increasing the number of gradient */</span>
    <span class="n">biases_</span><span class="o">-&gt;</span><span class="n">getParameterPtr</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incUpdate</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">syncFlag</span> <span class="o">=</span> <span class="n">hl_get_sync_flag</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">inputLayers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Calculate the W-gradient for the current layer */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getWGrad</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">MatrixPtr</span> <span class="n">input_T</span> <span class="o">=</span> <span class="n">getInputValue</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getTranspose</span><span class="p">();</span>
      <span class="n">MatrixPtr</span> <span class="n">oGrad</span> <span class="o">=</span> <span class="n">getOutputGrad</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getWGrad</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mul</span><span class="p">(</span><span class="n">input_T</span><span class="p">,</span> <span class="n">oGrad</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/* Calculate the input layers error */</span>
    <span class="n">MatrixPtr</span> <span class="n">preGrad</span> <span class="o">=</span> <span class="n">getInputGrad</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">preGrad</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MatrixPtr</span> <span class="n">weights_T</span> <span class="o">=</span> <span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getW</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTranspose</span><span class="p">();</span>
      <span class="n">preGrad</span><span class="o">-&gt;</span><span class="n">mul</span><span class="p">(</span><span class="n">getOutputGrad</span><span class="p">(),</span> <span class="n">weights_T</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">{</span>
      <span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getParameterPtr</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incUpdate</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">prefetch</span></code> function specifies the rows that need to be fetched from parameter server during training. It is only useful for remote sparse training. In remote sparse training, the full parameter matrix is stored distributedly at the parameter server. When the layer uses a batch for training, only a subset of locations of the input is non-zero in this batch. Thus, this layer only needs the rows of the transformation matrix corresponding to the locations of these non-zero entries. The <code class="docutils literal"><span class="pre">prefetch</span></code> function specifies the ids of these rows.</p>
<p>Most of the layers do not need remote sparse training function. You do not need to override this function in this case.</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">FullyConnectedLayer</span><span class="o">::</span><span class="n">prefetch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">inputLayers_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">*</span> <span class="n">sparseParam</span> <span class="o">=</span>
        <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="n">SparsePrefetchRowCpuMatrix</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">weights_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">getW</span><span class="p">().</span><span class="n">get</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sparseParam</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MatrixPtr</span> <span class="n">input</span> <span class="o">=</span> <span class="n">getInputValue</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">sparseParam</span><span class="o">-&gt;</span><span class="n">addRows</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, you can use <code class="docutils literal"><span class="pre">REGISTER_LAYER(fc,</span> <span class="pre">FullyConnectedLayer);</span></code> to register the layer. <code class="docutils literal"><span class="pre">fc</span></code> is the identifier of the layer, and <code class="docutils literal"><span class="pre">FullyConnectedLayer</span></code> is the class name of the layer.</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">paddle</span> <span class="p">{</span>
<span class="n">REGISTER_LAYER</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">FullyConnectedLayer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal"><span class="pre">cpp</span></code> file is put into <code class="docutils literal"><span class="pre">paddle/gserver/layers</span></code>, it will be automatically compiled.</p>
</div>
<div class="section" id="implement-python-wrapper">
<span id="implement-python-wrapper"></span><h1>Implement Python Wrapper<a class="headerlink" href="#implement-python-wrapper" title="Permalink to this headline">¶</a></h1>
<p>Implementing Python wrapper allows us to use the added layer in configuration files. All the Python wrappers are in file <code class="docutils literal"><span class="pre">python/paddle/trainer/config_parser.py</span></code>. An example of the Python wrapper for fully connected layer is listed below. It has the following steps:</p>
<ul class="simple">
<li>Use <code class="docutils literal"><span class="pre">&#64;config_layer('fc’)</span></code> at the decorator for all the Python wrapper class. <code class="docutils literal"><span class="pre">fc</span></code> is the identifier of the layer.</li>
<li>Implements <code class="docutils literal"><span class="pre">__init__</span></code> constructor function.<ul>
<li>It first call  <code class="docutils literal"><span class="pre">super(FCLayer,</span> <span class="pre">self).__init__(name,</span> <span class="pre">'fc',</span> <span class="pre">size,</span> <span class="pre">inputs=inputs,</span> <span class="pre">**xargs)</span></code> base constructor function. <code class="docutils literal"><span class="pre">FCLayer</span></code> is the Python wrapper class name, and <code class="docutils literal"><span class="pre">fc</span></code> is the layer identifier name. They must be correct in order for the wrapper to work.</li>
<li>Then it computes the size and format (whether sparse) of each transformation matrix as well as the size.</li>
</ul>
</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@config_layer</span><span class="p">(</span><span class="s1">&#39;fc&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FCLayer</span><span class="p">(</span><span class="n">LayerBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">,</span>
            <span class="n">bias</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">xargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FCLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;fc&#39;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">xargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_index</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">)):</span>
            <span class="n">input_layer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_input_layer</span><span class="p">(</span><span class="n">input_index</span><span class="p">)</span>
            <span class="n">psize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">input_layer</span><span class="o">.</span><span class="n">size</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_layer</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
            <span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span><span class="o">.</span><span class="n">format</span>
            <span class="n">sparse</span> <span class="o">=</span> <span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;csr&quot;</span> <span class="ow">or</span> <span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span>

            <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">psize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="n">input_index</span><span class="p">]</span><span class="o">.</span><span class="n">nnz</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">create_input_parameter</span><span class="p">(</span><span class="n">input_index</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_bias_parameter</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p>In network configuration, the layer can be specifies using the following code snippets. The arguments of this class are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> is the name identifier of the layer instance.</li>
<li><code class="docutils literal"><span class="pre">type</span></code> is the type of the layer, specified using layer identifier.</li>
<li><code class="docutils literal"><span class="pre">size</span></code> is the output size of the layer.</li>
<li><code class="docutils literal"><span class="pre">bias</span></code> specifies whether this layer instance has bias.</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code> specifies a list of layer instance names as inputs.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">Layer</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fc1&quot;</span><span class="p">,</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;fc&quot;</span><span class="p">,</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="n">bias</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Input</span><span class="p">(</span><span class="s2">&quot;pool3&quot;</span><span class="p">)]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>You are also recommended to implement a helper for the Python wrapper, which makes it easier to write models. You can refer to <code class="docutils literal"><span class="pre">python/paddle/trainer_config_helpers/layers.py</span></code> for examples.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Writing New Layers</a></li>
<li><a class="reference internal" href="#derive-equations">Derive Equations</a></li>
<li><a class="reference internal" href="#implement-c-class">Implement C++ Class</a></li>
<li><a class="reference internal" href="#implement-python-wrapper">Implement Python Wrapper</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../embedding_model/index.html"
                        title="previous chapter">Chinese Word Embedding Model Tutorial</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../cluster/index.html"
                        title="next chapter">Cluster Train</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/demo/new_layer/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../cluster/index.html" title="Cluster Train"
             >next</a> |</li>
        <li class="right" >
          <a href="../embedding_model/index.html" title="Chinese Word Embedding Model Tutorial"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PaddlePaddle  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Examples and demos</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, PaddlePaddle developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>